---
title: "POL501 - Solutions to Problem Set 3"
author: "Introduction to Statistics"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output: 
  word_document:
    toc: true
    toc_depth: 2
geometry: "left=1in,right=1in,top=1in,bottom=1in"
---
```{r setup, include=FALSE}
# Load necessary libraries - install using: install.packages() if needed
library(dplyr)
library(ggplot2)
library(haven)
library(tidyverse)
library(formatR)
library(psych)
library(kableExtra)
library(BSDA)
```

# Preliminary Setup.

## Demonstration of the function `confidence_interval` to compute confidence intervals 

First, we will start by defining a user defined function that will help us compute confidence intervals.

```{r func, echo=FALSE}
# Function to calculate confidence interval
confidence_interval <- function(data, var_name, confidence_level = 0.95, method = "t") {

  # Get the data column
  data_column <- data[[var_name]]
  
  # Check if inputs (method, var_name) are valid
  if (!(method %in% c("t", "z"))) {
    stop("Method must be either 't' or 'z'.")
  }
  if (!(var_name %in% colnames(data)) ) {
    stop("var_name must a string value of one of the columns in the df.")
  }
  
  # Calculate sample statistics
  sample_mean <- mean(data_column, na.rm = TRUE)
  sample_sd <- sd(data_column, na.rm = TRUE)
  n <- length(na.omit(data_column))
  standard_error <- sample_sd / sqrt(n)
  
  # Set alpha for confidence level
  alpha <- 1 - confidence_level
  
  # Calculate the critical value based on the selected method
  if (method == "t") {
    # t-distribution critical value
    critical_value <- qt(1 - alpha / 2, df = n - 1)
  } else {
    # z-distribution critical value
    critical_value <- qnorm(1 - alpha / 2)
  }
  
  # Calculate margin of error (MOE)
  margin_of_error <- critical_value * standard_error
  
  # Calculate confidence interval bounds
  lower_bound <- sample_mean - margin_of_error
  upper_bound <- sample_mean + margin_of_error
  
  # Prepare output as a named vector with dynamic variable name
  output <- c(
    `Sample Mean of` = {var_name},
    Estimate = round(sample_mean,3),
    MOE = round(margin_of_error,3),
    `Lower CI Bound` = round(lower_bound,3),
    `Upper CI Bound` = round(upper_bound,3)
  )

  # Return named vector
  return(output)
}
```

Now we will simulate some data and we will use this function as a demonstration:
```{r func-ex, echo=TRUE}
# Example usage with mock data
# Create a mock data frame with a column of ages
# We will assume Age follows a normal distribution with mean 45 and SD 10.
set.seed(123)
mock_data <- data.frame(age = abs(round(rnorm(100, mean = 45, sd = 10), 0)) )

# Let's visualize the simulated data
hist(mock_data$age)
```

Using this simulated data, we will illustrate the use of the new function to compute confidence intervals. Since, we simulated the data under the assumption of a normal distribution, we know that the sampling distribution of the sample mean for this population will follow a normal distribution. Hence, we will use the z critical values to compute the margin of error (MOE).

```{r func-ex-2, echo=TRUE}
# Calculate the confidence interval for the 'age' column with 95% confidence using the z-distribution
result_CI_z_95 <- confidence_interval(data = mock_data, var_name = 'age', confidence_level = 0.95, method = "z")

# Print
print(result_CI_z_95)

# Display using a table in the word doc - using `knitr::kable()` and using data.frame()
kable(data.frame(result_CI_z_95))
```
We can now plot this result, for better presentation. We can use ggplot to plot the result using a graph bar with whiskers representing the interval lower and upper bounds

```{r plot-ci, echo=TRUE}
# Extract the values from the result to use in the plot and Create a data frame for ggplot
plot_data <- data.frame(
  Estimate = result_CI_z_95["Estimate"],
  Lower = result_CI_z_95["Lower CI Bound"],
  Upper = result_CI_z_95["Upper CI Bound"]
)

# Plot using ggplot2 with a dot and whiskers for confidence interval
ggplot(plot_data, aes(x = "Age", y = Estimate)) +
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.1, color = "steelblue") +  # Whiskers for CI
  geom_point(size = 3, color = "navyblue") +  # Dot for the sample mean
  labs(
    title = "Sample Mean of Age with 95% Confidence Interval",
    x = "",
    y = "Age"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```

Note that if we want a confidence interval with 99% confidence we can just change the appropriate input of the function:

```{r func-ex-3, echo=TRUE}
# Calculate the confidence interval for the 'age' column with 99% confidence using the z-distribution
result_CI_z_99 <- confidence_interval(data=mock_data, var_name='age', confidence_level = 0.99, method = "z")

# Print
print(result_CI_z_99)

# Display using a table in the word doc - using `knitr::kable()` and using data.frame()
kable(data.frame(result_CI_z_99))
```

If we compute multiple confidence intervals of different confidence levels, or different variables, we can join the results using `cbind`
```{r, echo=TRUE}
# Demonstration of `cbind`
merge_columns <- cbind(result_CI_z_95, result_CI_z_99)
print(merge_columns)

# Display using a table in the word doc - using `kable` and `data.frame`
kable(data.frame(merge_columns))
```
 
## Demonstration of the command `z.test` to run hypothesis tests

The `z.test` function is used to test the null hypothesis that the mean of a sample is equal to a hypothesized population mean. This test is appropriate when the sample size is large (typically n > 30) or the population standard deviation is known and the underlying random variable follows a normal distribution. We can run the test to determine if there is evidence to suggest that the sample mean differs from a specified value.

To run the z-test, we will first install the package `BSDA` which contains the `z.test` function. This package includes useful statistical methods for data analysis.

```{r install-bsda, echo=TRUE, eval=FALSE}
# Install BSDA package if not already installed
if (!requireNamespace("BSDA", quietly = TRUE)) {
  install.packages("BSDA")
}
```
Once the package is installed, we can run the `z.test` on our mock data to determine if the mean age differs from 45 years.

```{r z-test, echo=TRUE}
# Load BSDA library
library(BSDA)

# Run the z-test on the age data to test if the mean is significantly different from 45
z_test_result <- z.test(
  x = mock_data$age,
  mu = 45,  # Hypothesized population mean
  sigma.x = sd(mock_data$age),  # Population standard deviation (we are assuming known)
  conf.level = 0.95
)

# Print the z-test result
print(z_test_result)
```
In the output, we get the z-value, the p-value, and the confidence interval of the sample mean. The p-value helps us determine whether we can reject the null hypothesis. If the p-value is less than the significance level (typically 0.05), we reject the null hypothesis and conclude that there is sufficient evidence to suggest that the sample mean differs from the hypothesized population mean.

The confidence interval also gives us an idea of the range in which the true population mean lies, with a given level of confidence.

Here we see that the p-value is higher than 0.10 therefore, we cannot reject the null hypothesis that the true mean is equal to 45.

\newpage

___
# Question 1

## Preliminary Steps.

Preliminaries. First, start by declaring the directory (folder) in which you have the data.
```{r q1-setup-1, echo=TRUE}
## Setting Up the Directory (REPLACE WITH YOUR FOLDER)
##    You must use the "/" character or "\\" to separate folders:
setwd("F:/Dropbox/PhD SBU/06_Teaching/00_POL-501/Problem Sets/PS-3")

## Confirm the working directory
getwd()
```
**Important**: 

- You must place this RMD file in the same folder in which you have the data. 

- Then, you will be able to load the dataset to memory. The name of the dataset as an R object is `df_clean`.

```{r q1-setup-2, echo=TRUE}
# Load the dataset.
load('dataframe-pew.RData')
# Check the objects loaded
ls()
```


## Answer to (1.a)
```{r q1-a, echo=TRUE}
# Question 1.a: using the function `confidence_interval` compute the mean of `CRIMESAFE` using a 95% confidence level. Interpret the result appropriately (i.e., describe what the confidence interval is conveying)
crimesafe_CI_z_95 <- confidence_interval(data = df_clean, var= 'CRIMESAFE', confidence_level = 0.95, method = "z")

print(crimesafe_CI_z_95)
```

**Explanation/Justification:**
The confidence interval for CRIMESAFE at a 95% confidence level provides a range within which we can be 95% confident that the true mean perception of community safety falls. This interval helps estimate the general safety perception across the population based on our sample data. 

From the variable's codebook we know that:

CRIMESAFE. How would you describe the area where you live, in terms of crime?

 – 1 = Extremely safe
 – 2 = Very safe
 – 3 = Somewhat safe
 – 4 = Not too safe
 – 5 = Not at all safe

Hence, we can conclude that the sample mean of 2.575, with a 95% confidence interval from 2.552 to 2.598, suggests that the general perception of community safety among respondents falls between "Very safe" (2) and "Somewhat safe" (3). Given that the mean is closer to 2, it indicates that respondents, on average, lean toward feeling that their area is relatively safe, though not without some concerns.

This interval provides a reliable estimate of the population's perception of safety based on the sample. The small margin of error (MOE = 0.023) and narrow confidence interval imply that we have a precise estimate, giving us confidence in the stability of this perception across the surveyed population.
  
## Answer to (1.b)
```{r, echo=TRUE}
# Question 1.b: using the function `confidence_interval` compute the mean of `CRIMESAFE` using a 99% confidence level. Explain any differences you find from your answer in 1.a

crimesafe_CI_z_99 <- confidence_interval(data = df_clean, var_name='CRIMESAFE', confidence_level = 0.99, method = "z")
print(crimesafe_CI_z_99)

```

**Explanation/Justification:**
  (your justification goes here)
  
## Answer to (1.c)
```{r, echo=TRUE}
# Question 1.c: Using the `dyplr` command 'filter' create one data frame including a subsample for the responses of democrats, and another for republicans.

df_dems <- df_clean %>% filter(PARTY == 2) #  "Democrat" == 2
df_rep <- df_clean %>% filter(PARTY == 1) # "Republican" == 1 

```

**Explanation/Justification:**
  (your justification goes here)

## Answer to (1.d)
```{r, echo=TRUE}
# Question 1.d: Compute the sample mean for `CRIMESAFE` and 95% confidence intervals separately for the democrats subsample and the republican subsample 

crimesafe_CI_z_95_dems <- confidence_interval(data = df_dems, var_name='CRIMESAFE', confidence_level = 0.95, method = "z")
cat('\nResults for Democrats:\n')
print(crimesafe_CI_z_95_dems)

crimesafe_CI_z_95_reps <- confidence_interval(data = df_rep, var_name='CRIMESAFE', confidence_level = 0.95, method = "z")
cat('\nResults for Republicans:\n')
print(crimesafe_CI_z_95_reps)


```

**Explanation/Justification:**
  (your justification goes here)


## Answer to (1.e) - After completing (1.d) you just need to run this chunk and interpret the results. Your job here is the interpreation and explanaition. 
```{r, echo=TRUE}
# Question 1.e: Create one dataframe in which the first row includes the results of (1.d) for democrats and the second row for republican subsamples. Then, plot the results. Finally (and most importantly), interpret the results. Do the confidence intervals overlap, if so, what could this suggest?

# Extract the values from the result to use in the plot
combined_crimesafe_CI_95 <- cbind(c(Group='Democrats',
                                    crimesafe_CI_z_95_dems), 
                                  c(Group='Republicans',
                                    crimesafe_CI_z_95_reps))

# Convert the combined matrix into a data frame with proper column names
df_combined_CI <- as.data.frame(t(combined_crimesafe_CI_95), stringsAsFactors = FALSE)

# Rename columns for clarity
colnames(df_combined_CI) <- c("Group", "Sample_Mean", "Estimate", "MOE", "Lower", "Upper")

# Convert relevant columns to numeric
df_combined_CI <- df_combined_CI %>%
  mutate(Estimate = as.numeric(Estimate),
         Lower = as.numeric(Lower),
         Upper = as.numeric(Upper))

# Plot using ggplot2 with a dot and whiskers for confidence interval
ggplot(df_combined_CI, aes(x = Group, y = Estimate)) +
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.1, color = "steelblue") +  # Whiskers for CI
  geom_point(size = 3, color = "navyblue") +  # Dot for the sample mean
  labs(
    title = "Mean Perception of Community Safety with 95% Confidence Interval",
    x = "Political Affiliation",
    y = "Perception of Community Safety (CRIMESAFE)"
  ) +
  theme_minimal() + 
  ylim(2.4, 2.7)  # Set the y-axis limits here


```

**Explanation/Justification:**
  (your answer goes here)
  

___
# Question 2

This questions follows the previous one. Now we focus on inference for proportions specifically.

## Answer to (2.a) - Run this chunk and interpret the results.
```{r, echo=TRUE}
# Question 2.a: create a new variable in the dataframe `df_clean` that is equal to 1 if the respondent selected  – 4 = Not too safe or – 5 = Not at all safe, and zero otherwise. Following that, recreate the subsample data frames for dems and reps. Then, interpret the results using the concept of a proportion.
df_clean <- df_clean %>%
  mutate(
    notsafe_binary = if_else(
      # if CRIMESAFE equals 4 or 5, then assign a =1 to the new variable, else assign a =0.
      CRIMESAFE %in% c(4, 5), 1, 0
    )
  )

df_dems <- df_clean %>% filter(PARTY == 2) #  "Democrat" == 2
df_rep <- df_clean %>% filter(PARTY == 1) # "Republican" == 1 

# Describe the mean of the new variable
mean(df_clean$notsafe_binary)

# Describe the mean of the new variable for democrats
mean(df_dems$notsafe_binary)

# Describe the mean of the new variable for republicans
mean(df_rep$notsafe_binary)

```

**Explanation/Justification:**

  (your answer and interpretation of results goes here)

## Answer to (2.b) - 
```{r, echo=TRUE, eval=FALSE}
# Question 2.b: Using the subsample for democrats, and the command z.test run a hypothesis test with 5 significance level (aka, 95% confidence level) with null hypothesis establishing that the true proportion for democrats that say their community is 'not too safe' or 'not at all safe' is diffeent than the sample propoortion estimate you got from the subsample of republicans.

prop_null_hypothesis <- mean(df_rep$notsafe_binary)
n_sample_size <- nrow(df_dems)

# Using `prop_null_hypothesis` and `n_sample_size` and `sqrt()` replace with the appropiate formula:
standard_error_null_hypot <- 'Replace with the formula VALUE FOR THE TEST'
  
# Run the z-test on the age data to test if the mean is significantly different from the sample proportion for republicans
z_test_result <- z.test(
  x = df_dems$CRIMESAFE,
  mu = prop_null_hypothesis,  # Hypothesized population mean
  sigma.x = standard_error_null_hypot,  # Population standard deviation (we are assuming known)
  conf.level = 0.95
)

# Print the z-test result
print(z_test_result)

```

**Explanation/Justification:**

  (your answer and interpretation of results goes here)


## Answer to (2.c) - 
```{r, echo=TRUE, eval=FALSE}
# Question 2.c: Using the subsample for republicans, and the command z.test run a hypothesis test with 1 significance level (aka, 99% confidence level) with null hypothesis establishing that the true proportion for republicans that say their community is 'not too safe' or 'not at all safe' is diffeent than the sample propoortion estimate you got from the subsample of democrats

prop_null_hypothesis <- mean(df_dems$notsafe_binary)
n_sample_size <- nrow(df_dems)

# Using `prop_null_hypothesis` and `n_sample_size_dems` and `sqrt()` replace with the appropiate formula:
standard_error_null_hypot <- 'Replace with the formula VALUE FOR THE TEST'
  
# Run the z-test on the age data to test if the mean is significantly different from the sample proportion for republicans
z_test_result <- z.test(
  x = df_dems$CRIMESAFE,
  mu = prop_null_hypothesis,  # Hypothesized population mean
  sigma.x = standard_error_null_hypot,  # Population standard deviation (we are assuming known)
  conf.level = 0.99
)

# Print the z-test result
print(z_test_result)

```

**Explanation/Justification:**

  (your answer and interpretation of results goes here)



